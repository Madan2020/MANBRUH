#!/bin/bash

# This script demonstrates how to trap signals and handle them using functions

# Task: Add traps for the INT and QUIT signals. If the script receives an INT signal,
#       reset the count to the maximum and tell the user they are not allowed to interrupt
#       the count. If the script receives a QUIT signal, tell the user they found the secret
#       to getting out of the script and exit immediately.

#### Variables
programName="$0" # used by error_functions.sh
sleepTime=1 # delay used by sleeptime
numberOfSleeps=10 # how many sleeps to wait for before quitting for inactivity

#### Functions

# This function will send an error message to stderr
# Usage:
#   error-message ["some text to print to stderr"]
#

trap max_count SIGINT # provoking max_count function if SIGINT is generated. i.e generated by using ctrl + c (Numeric value of SIGINT is 2)
trap secret 3	# provoking secret function if SIGQUIT (numeric value 3) is generated


function secret { # creating function
  echo "You found the secret for getting out of the script" # code to execute if function is called
  exit
} # closing function

function max_count { #creating function
  echo "You are not allowed to interrupt the count" #code to execute if function is called
  sleepCount=$(($NumberOfSleeps+20)) # increasing value of sleepcount to max

} # closing function

function error-message {
        local prog=`basename $0`
        echo "${prog}: ${1:-Unknown Error - a moose bit my sister once...}" >&2
}

# This function will send a message to stderr and exit with a failure status
# Usage:
#   error-exit ["some text to print" [exit-status]]
#

function error-exit {
        error-message "$1"
        exit "${2:-1}"
}
function usage {
        cat <<EOF
Usage: ${programName} [-h|--help ] [-w|--waittime waittime] [-n|--waitcount waitcount]
Default waittime is 1, waitcount is 10
EOF
}

# Normally traps catch signals and do something useful or necessary with them


# Produce the numbers for the countdown
function doCountdown {
while [ $sleepCount -gt 0 ]; do # runs loop until value of varaible sleepCount is greater than 0.
    echo $((sleepCount * 100 / $numberOfSleeps)) # code to be executed if condition is true
    sleepCount=$((sleepCount - 1)) # decreasing value of sleepcount by 1
    sleep $sleepTime # sleep command is used as countdown function
done # closing while loop
}

#### Main Program

# Process command line parameters
while [ $# -gt 0 ]; do # runs loop until number of arguments is greater than 0
    case $1 in # if condition is true using case statement to check various values for $1. case statement is substitute of if statement if various possible values for single variable is to be checked.
        -w | --waittime ) # if -w or --waittime is in $1 the following sequence of command are executed.
            shift # shift command shifts the value of argument simultaneously to previous ones
            sleepTime="$1"
            ;; # closing case option
        -n | --waitcount) # if -n or --waitcount is in $1 the following sequence of command are executed.
            shift # shift command shifts the value of argument simultaneously to previous ones
            numberOfSleeps="$1"
            ;; # closing case option
        -h | --help ) # if -h or --help is in $1 the following sequence of command are executed.
            usage
            exit # exits the program
            ;; # closing case option
        * ) # anything besides above mentioned cases is available in $1 following sequence of command are executed.
            usage
            error-exit "$1 not a recognized option" # alerts user that the provided option is not recognized.
    esac # closing case statement
    shift # shifting value of variables simultaneously
done # closing while statement

if [ ! $numberOfSleeps -gt 0 ]; then # check if value of numberOfSleeps is greater than 0
    error-exit "$numberOfSleeps is not a valid count of sleeps to wait for signals" #sequence of command to be executed if value of numberOfSleeps is greater than 0
fi # closing if statement

if [ ! $sleepTime -gt 0 ]; then # check if value of sleepTime is greater than 0
    error-exit "$sleepTime is not a valid time to sleep while waiting for signals" #sequence of command to be executed if value of numberOfSleeps is greater than 0
fi # closing if statement


sleepCount=$numberOfSleeps

while [ $sleepCount -gt 0 ]; do # runs loop until calue of sleepcount is greater than 0
doCountdown|dialog --gauge "Remaining Time" 7 60 # calling doCountdown function alongside dialog command for GUI presentation
stty sane
sleepCount=$((sleepCount - 10)) # decreasing value of sleepcount by 10
done # closing while loop


echo "Wait counter expired, exiting peacefully" # alertins user that program is exiting
